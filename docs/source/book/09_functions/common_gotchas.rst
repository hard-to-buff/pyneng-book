Распространенные проблемы/нюансы работы с функциями
---------------------------------------------------

Список/словарь в который собираются данные в функции, создан за пределами функции
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Очень часто в решении заданий встречается такой нюанс: функция должна собрать какие-то данные в список/словарь
и список создан вне функции. Тогда вроде как функция работает правильно,
но при этом тест не проходит. Это происходит потому что в таком варианте функция
работает неправильно и каждый вызов добавляет элементы в тот же список:

.. code:: python

    In [1]: result = []

    In [2]: def func(items):
       ...:     for i in items:
       ...:         result.append(i*100)
       ...:     return result
       ...:

    In [3]: func([1, 2, 3])
    Out[3]: [100, 200, 300]

    In [4]: func([7, 8])
    Out[4]: [100, 200, 300, 700, 800]

Исправить это можно переносом строки создания списка в функцию:

.. code:: python

    In [20]: def func(items):
        ...:     result = []
        ...:     for i in items:
        ...:         result.append(i*100)
        ...:     return result
        ...:

    In [21]: func([1, 2, 3])
    Out[21]: [100, 200, 300]

    In [22]: func([7, 8])
    Out[22]: [700, 800]

Всё, что относится к функции лучше всегда писать внутри функции.
Тест тут не проходит потому что внутри файла задания функция вызывается первый
раз - всё правильно, а потом тест вызывает её второй раз и там вдруг в два раза больше данных чем нужно.

Значения по умолчанию в параметрах создаются во время создания функции
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Пример функции, которая должна выводить текущую дату и время при каждом вызове:

.. code:: python

    In [1]: from datetime import datetime

    In [2]: import time

    In [3]: def print_current_datetime(ptime=datetime.now()):
       ...:     print(f">>> {ptime}")
       ...:

    In [4]: for i in range(3):
       ...:     print("Имитируем долгое выполнение...")
       ...:     time.sleep(1)
       ...:     print_current_datetime()
       ...:
    Имитируем долгое выполнение...
    >>> 2021-02-23 09:01:49.845425
    Имитируем долгое выполнение...
    >>> 2021-02-23 09:01:49.845425
    Имитируем долгое выполнение...
    >>> 2021-02-23 09:01:49.845425

Так как ``datetime.now()`` указано в значении по умолчанию,
это значение создается во время создания функции и в итоге при каждом вызове
время одно и то же. Для корректного вывода, надо вызывать ``datetime.now()``
в теле функции:

.. code:: python

    In [5]: def print_current_datetime():
       ...:     print(f">>> {datetime.now()}")
       ...:


Второй пример где этот нюанс может привести к неожиданным результатам,
если о нем не знать - изменяемые типы данных в значении по умолчанию.

Например, использование списка в значении по умолчанию:

.. code:: python

    In [15]: def add_item(item, data=[]):
        ...:     data.append(item)
        ...:     return data
        ...:

В этом случае список data создается один раз - при создании функции и
при вызове функции, данные добавляются в один и тот же список.
В итоге все повторные вызовы будут добавлять элементы:

.. code:: python

    In [16]: add_item(1)
    Out[16]: [1]

    In [17]: add_item(2)
    Out[17]: [1, 2]

    In [18]: add_item(4)
    Out[18]: [1, 2, 4]

Если нужно сделать так, чтобы параметр data был необязательным и по умолчанию
создавался пустой список, надо сделать так:

.. code:: python

    In [22]: def add_item(item, data=None):
        ...:     if data is None:
        ...:         data = []
        ...:     data.append(item)
        ...:     return data
        ...:

    In [23]: add_item(1)
    Out[23]: [1]

    In [24]: add_item(2)
    Out[24]: [2]

